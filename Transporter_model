import numpy
import pylab
import random
import math
import copy
#initialization section

n=1000#number of timesteps taken
#numberline=numpy.arange(n)
k=0 #number of "type 1" particles spawning in area one
g=0 #number of "type 1" particles spawning in area 2
c=0 #number of "type 2" particles spawning in area one
f=0 #number of "type 2" particles spawning in area 2
Type_One = range(0, (k + g))
Type_Two = range((k + g), (k + c + g + f))
x_bound_low=-1#lower bound for x and x-randomization
x_bound_high=10#upper bound for x and x-randomization
h=10#separates areas into area one and area two, and sets y inter-area boundrary
uph=15
y_bound_low=-1#lower bound for y and y-randomization
y_bound_high=21#upper bound for y and y randomization
Special_Trans1=((5), (7))#sets part of transporter which rejects type one particles
Special_Trans2=((6), (8))#sets part of transporter which rejects type two particles
#in order for this to work, they must have the same number of entries
DC1 = ([x_bound_low], [x_bound_high])#sets upper and lower boundaries at x=1  and x=10
DC3 = ([y_bound_low], [y_bound_high])#sets upper and lower y boundaries and the cell membrane level
DC4 = (numpy.arange(h, (uph + 1)))#sets width of interarea boundary
M = numpy.array([(-1,-1),(-1,0),(-1,1),(0,-1),(0,0),(1,-1),(1,0),(0,1),(1,1)])
A1T1x = numpy.random.randint(low=x_bound_low + 1, high=x_bound_high, size =((k), 1))#randomization for area one x-bound
A1T1y = numpy.random.randint(low=y_bound_low + 1, high=h, size =((k), 1))#randomization for area one y-bound
A1T1 = numpy.concatenate((A1T1x, A1T1y), axis= 1)#matrix of positions of area one
A2T1x = numpy.random.randint(low=x_bound_low + 1, high=x_bound_high, size =((g), 1))#randomization for area two x-bound
A2T1y = numpy.random.randint(low=uph + 1, high=y_bound_high, size =((g), 1))#randomization for area two y-bound
A2T1 = numpy.concatenate((A2T1x, A2T1y), axis= 1)#matrix of positions of area two
A1T2x = numpy.random.randint(low=x_bound_low + 1, high=x_bound_high, size =((c), 1))#randomization for area one x-bound
A1T2y = numpy.random.randint(low=y_bound_low + 1, high=h, size =((c), 1))#randomization for area one y-bound
A1T2 = numpy.concatenate((A1T2x, A1T2y), axis= 1)#matrix of positions of area one
A2T2x = numpy.random.randint(low=x_bound_low + 1, high=x_bound_high, size =((f), 1))#randomization for area two x-bound
A2T2y = numpy.random.randint(low=uph + 1, high=y_bound_high, size =((f), 1))#randomization for area two y-bound
A2T2 = numpy.concatenate((A2T2x, A2T2y), axis= 1)#matrix of positions of area two
P = numpy.concatenate((A1T1, A2T1, A1T2, A2T2), axis= 0)#sets matrix of positions, with particles spawning in area two being below those spawning in area one
x = numpy.hsplit(P, 2)
#Return_To_Start = P.copy()
x_cord = x[0]#sets matrix of all x coordinates of all particles
y_cord = x[1]#sets matrix of all y coordinates of all particles
Ising = numpy.random.randint(low=0, high=2, size =(len(Special_Trans1), len(DC4)))#randomization for area one x-bound
ones=numpy.transpose(numpy.matrix([-1, -1]))
Idontsing = numpy.concatenate((ones, Ising, ones), axis=1)
Transporter_y_cord = numpy.arange(0, len(Special_Trans1))
Transrand = len(DC4) - 1#sets number of transporters acting as such
E = numpy.zeros(((len(DC4)) * Transrand * 2) + k + c + g + f)
Special = (Special_Trans1, Special_Trans2)
Sppecial = numpy.zeros((len(Special_Trans1), 2))
for u in range(0, len(Special_Trans1)):
    Sppecial[u] = [item[u] for item in Special]
KbT=1
epsilon=1
negepsilion=-1
type1lows = numpy.zeros(n)#counts what particles of what types are in what area
type1highs = numpy.zeros(n)
type2lows = numpy.zeros(n)
type2highs = numpy.zeros(n)
def Transporter_Energy():
    print("Transporter Energy")
    for q in range(0, Transrand + 1):
        if (j - ((len(Special_Trans1) * q) + (k + c + g + f))) in Transporter_y_cord:
            u = (j - ((len(Special_Trans1) * q) + (k + c + g + f)))
            print("this", u, j, q)
            v = q + 1
            break
    print(Idontsing)
    print("here", j, v, u, Idontsing[u])
    if Idontsing[u, v] == 1:
        Idontsing[u, v] = 0
        if Idontsing[u, v - 1] == 1:
            E_component1 = negepsilion
        if Idontsing[u, v + 1] == 1:
            E_component2 = negepsilion
        for j in range(0, (k + c + g + f)):
            if y_cord[j] == DC4[q] and x_cord[j] in Sppecial[u]:
                Epartcount = Epartcount - negepsilion#accounts for change in particle energy within transporter when it's changing
                copy.copy(Epartcount)
    elif Idontsing[u, v] == 0:
        Idontsing[u, v] = 1
        if Idontsing[u, v - 1] == 0:
            E_component1 = negepsilion
        if Idontsing[u, v + 1] == 0:
            E_component2 = negepsilion
        for j in range(0, (k + c + g + f)):
            if y_cord[j] == DC4[q] and x_cord[j] in Sppecial[v]:
                Epartcount = Epartcount + negepsilion#accounts for change in particle energy within transporter when it's changing
                copy.copy(Epartcount)
    E[j] = E_component1 + E_component2 + Epartcount
    print("Ecomponents", E_component1, E_component2, E[j])
def Particle_Energy():
    print("Particle Energy")
    if DC1 in x_cord[j]:#keeps particles from leaving the system's boundaries
        E[j] = math.inf#energy set to infinite if particle runs into x boundaries
    elif DC3 in y_cord[j]:#this isn't the best solution, as it runs through everything a couple times, however, it does have 100% accuracy
        E[j] = math.inf#energy set to infinite if particle runs into y boundaries and membrane
    elif DC4 in y_cord[j]:#this isn't the best solution, as it runs through everything a couple times, however, it does have 100% accuracy
        if Special_Trans1 in x_cord[j]:#sets which"end" of transporter is altered
            if j in range(0, (k + g)):
                E[j] = math.inf#rejects type one particles from entering the special transporters from this way
            elif Idontsing[Special_Trans1.index(x_cord[j])][y_cord[j] - h] == 0:
                E[j] = negepsilion#sets energy for particle interaction within channel
            else:
                E[j] = 0
        elif Special_Trans2 in x_cord[j]:
            if j in range((k + g), (k + c + g + f)):
                E[j] = math.inf#rejects type two particles from entering the special transporters from this way
            elif Idontsing[Special_Trans2.index(x_cord[j])][y_cord[j] - h] == 0:
                E[j] = negepsilion
            else:
                E[j] = 0
        else:
            E[j] = math.inf
    else:
        E[j] = 0#default energy is 0
for i in range(0, n):
    print(i)
    type1low = 0
    type1high = 0
    type2low = 0
    type2high = 0
    Epartcount = 0
    E_component1 = 0
    E_component2 = 0
    j = random.randint(0, ((k + c + g + f) + (len(DC4) * len(Special_Trans1)) - 1))#this picks which particle moves
    E_old = E.copy() #saves old energy matrix in case the new move is rejected
    Ej_old = E[j].copy()#saves old individual energy for use in Monte Carlo rejection
    I_old = Idontsing.copy()
    if j in range(0, (k + c + g + f)):
        P_old = P[j].copy() #saves old position in case the new move is rejected
        P[j] = P_old + random.choice(M) #the new move
        Particle_Energy()
    elif j in range((k + c + g + f), ((len(DC4) * len(Special_Trans1)) + (k + c + g + f))):
        print("cool")
        for q in range(0, Transrand + 1):
            if (j - ((len(Special_Trans1) * q) + (k + c + g + f))) in Transporter_y_cord:
                u = (j - ((len(Special_Trans1) * q) + (k + c + g + f)))
                print("this", u, j, q)
                v = q + 1
                break
        print(Idontsing)
        print("here", j, v, u, Idontsing[u])
        if Idontsing[u, v] == 1:
            Idontsing[u, v] = 0
            if Idontsing[u, v - 1] == 1:
                E_component1 = negepsilion
            if Idontsing[u, v + 1] == 1:
                E_component2 = negepsilion
            for j in range(0, (k + c + g + f)):
                if y_cord[j] == DC4[q] and x_cord[j] in Sppecial[u]:
                    Epartcount = Epartcount - negepsilion#accounts for change in particle energy within transporter when it's changing
                    copy.copy(Epartcount)
        elif Idontsing[u, v] == 0:
            Idontsing[u, v] = 1
            if Idontsing[u, v - 1] == 0:
                E_component1 = negepsilion
            if Idontsing[u, v + 1] == 0:
                E_component2 = negepsilion
            for j in range(0, (k + c + g + f)):
                if y_cord[j] == DC4[q] and x_cord[j] in Sppecial[v]:
                    Epartcount = Epartcount + negepsilion#accounts for change in particle energy within transporter when it's changing
                    copy.copy(Epartcount)
        E[j] = E_component1 + E_component2 + Epartcount
        print("Ecomponents", E_component1, E_component2, E[j])
        for j in range(j - 1, j + 2):
            Transporter_Energy()
        for j in range(0, (k + c + g + f)):
            Particle_Energy()
    if E[j] > Ej_old:#if the energy's lower or equal we automatically accept it
        val = numpy.random.uniform(low=0, high=1, size=1)
        if val > (math.exp((Ej_old - E[j])/(KbT))):#equation will need to be changed later(rn inaccurate)
            if j in range(0, (k + c + g + f)): #resets to old state if the move is rejected
                P[j] = P_old
            print("E[j]=", E[j])
            print("Ej_old", Ej_old)
            print(Idontsing)
            E = E_old
            Idontsing = I_old
            print(Idontsing)
            print("blocked")
