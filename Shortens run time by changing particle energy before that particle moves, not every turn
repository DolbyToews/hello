import numpy
import pylab
import random
import math
import copy
Transporter=0
Particle=1
mode=Particle
n=10000#number of timesteps taken
#numberline=numpy.arange(n)
TypeN_Area1Spawn=10 #number of "type 1" particles spawning in area one
TypeN_Area2Spawn=0 #number of "type 1" particles spawning in area 2
TypeS_Area1Spawn=10 #number of "type 2" particles spawning in area one
TypeS_Area2Spawn=10 #number of "type 2" particles spawning in area 2
Type_N = range(0, (TypeN_Area1Spawn + TypeN_Area2Spawn))
Type_S = range((TypeN_Area1Spawn + TypeN_Area2Spawn), ((TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn)))
x_bound_low=-1#lower bound for x and x-randomization
x_bound_high=10#upper bound for x and x-randomization
h=10#separates areas into area one and area two, and sets y inter-area boundrary
uph=12
y_bound_low=-1#lower bound for y and y-randomization
y_bound_high=21#upper bound for y and y randomization
TypeN_Transporter_Channel=((5), (7))#sets part of transporter which rejects type one particles
TypeS_Transporter_Channel=((6), (8))#sets part of transporter which rejects type two particles
#in order for this to work, they must have the same number of entries
x_bounds = ([x_bound_low], [x_bound_high])#sets upper and lower boundaries at x=1  and x=10
y_bounds = ([y_bound_low], [y_bound_high])#sets upper and lower y boundaries and the cell membrane level
Cell_Membrane = (numpy.arange(h, (uph + 1)))#sets width of interarea boundary
Eligible_Moves = numpy.array([(-1,-1),(-1,0),(-1,1),(0,-1),(0,0),(1,-1),(1,0),(0,1),(1,1)])
A1T1x = numpy.random.randint(low=x_bound_low + 1, high=x_bound_high, size =((TypeN_Area1Spawn), 1))#randomization for area one x-bound
A1T1y = numpy.random.randint(low=y_bound_low + 1, high=h, size =((TypeN_Area1Spawn), 1))#randomization for area one y-bound
A1T1 = numpy.concatenate((A1T1x, A1T1y), axis= 1)#matrix of positions of area one
A2T1x = numpy.random.randint(low=x_bound_low + 1, high=x_bound_high, size =((TypeN_Area2Spawn), 1))#randomization for area two x-bound
A2T1y = numpy.random.randint(low=uph + 1, high=y_bound_high, size =((TypeN_Area2Spawn), 1))#randomization for area two y-bound
A2T1 = numpy.concatenate((A2T1x, A2T1y), axis= 1)#matrix of positions of area two
A1T2x = numpy.random.randint(low=x_bound_low + 1, high=x_bound_high, size =((TypeS_Area1Spawn), 1))#randomization for area one x-bound
A1T2y = numpy.random.randint(low=y_bound_low + 1, high=h, size =((TypeS_Area1Spawn), 1))#randomization for area one y-bound
A1T2 = numpy.concatenate((A1T2x, A1T2y), axis= 1)#matrix of positions of area one
A2T2x = numpy.random.randint(low=x_bound_low + 1, high=x_bound_high, size =((TypeS_Area2Spawn), 1))#randomization for area two x-bound
A2T2y = numpy.random.randint(low=uph + 1, high=y_bound_high, size =((TypeS_Area2Spawn), 1))#randomization for area two y-bound
A2T2 = numpy.concatenate((A2T2x, A2T2y), axis= 1)#matrix of positions of area two
Position_Matrix = numpy.concatenate((A1T1, A2T1, A1T2, A2T2), axis= 0)#sets matrix of positions, with particles spawning in area two being below those spawning in area one
x = numpy.hsplit(Position_Matrix, 2)
#Return_To_Start = P.copy()
x_cord = x[0]#sets matrix of all x coordinates of all particles
y_cord = x[1]#sets matrix of all y coordinates of all particles
if mode == 0:
    Ising = numpy.random.randint(low=0, high=2, size =(len(TypeN_Transporter_Channel), len(Cell_Membrane)))#randomization for area one x-bound
    ones=numpy.transpose(numpy.matrix([-1, -1]))
    Ising_Dummy_Ends = numpy.concatenate((ones, Ising, ones), axis=1)
Transporter_y_cord = numpy.arange(0, len(TypeN_Transporter_Channel))
E = numpy.zeros(((len(Cell_Membrane) + 1) * len(TypeN_Transporter_Channel)) + (TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn))
Special = (TypeN_Transporter_Channel, TypeS_Transporter_Channel)
Transporter_List = numpy.zeros((len(TypeN_Transporter_Channel), 2))
o1 = numpy.zeros((((y_bound_high - y_bound_low)), ((x_bound_high - x_bound_low))))#occupancy matrix
for j in range(0, (TypeN_Area1Spawn + TypeN_Area2Spawn)):#sets all starting positions to occupied
    o1[((y_cord[j] - (y_bound_low + 1)), (x_cord[j] - (x_bound_low + 1)))] = o1[((y_cord[j] - (y_bound_low + 1)), (x_cord[j] - (x_bound_low + 1)))] + 1    
o2 = numpy.zeros((((y_bound_high - y_bound_low)), ((x_bound_high - x_bound_low))))#occupancy matrix
for j in range((TypeN_Area1Spawn + TypeN_Area2Spawn), (TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn)):#sets all starting positions to occupied
    o2[((y_cord[j] - (y_bound_low + 1)), (x_cord[j] - (x_bound_low + 1)))] = o2[((y_cord[j] - (y_bound_low + 1)), (x_cord[j] - (x_bound_low + 1)))] + 1 
Type1j_Matrix = [[o1[(((y_cord[j] - (y_bound_low + 1) - 1)), ((x_cord[j] - (x_bound_low + 1)) - 1))]], [o1[(((y_cord[j] - (y_bound_low + 1)) - 1), (x_cord[j] - (x_bound_low + 1)))]], [o1[(((y_cord[j] - (y_bound_low + 1)) - 1), ((x_cord[j] - (x_bound_low + 1)) + 1))]], [o1[((y_cord[j] - (y_bound_low + 1)), ((x_cord[j] - (x_bound_low + 1)) - 1))]], [o1[((y_cord[j] - (y_bound_low + 1)), (x_cord[j] - (x_bound_low + 1)))]], [o1[((y_cord[j] - (y_bound_low + 1)), ((x_cord[j] - (x_bound_low + 1)) + 1))]], [o1[(((y_cord[j] - (y_bound_low + 1)) + 1), ((x_cord[j] - (x_bound_low + 1)) - 1))]], [o1[(((y_cord[j] - (y_bound_low + 1)) + 1), (x_cord[j] - (x_bound_low + 1)))]], [o1[(((y_cord[j] - (y_bound_low + 1)) + 1), ((x_cord[j] - (x_bound_low + 1)) + 1))]]]
Type2j_Matrix = [[o2[(((y_cord[j] - (y_bound_low + 1) - 1)), ((x_cord[j] - (x_bound_low + 1)) - 1))]], [o2[(((y_cord[j] - (y_bound_low + 1)) - 1), (x_cord[j] - (x_bound_low + 1)))]], [o2[(((y_cord[j] - (y_bound_low + 1)) - 1), ((x_cord[j] - (x_bound_low + 1)) + 1))]], [o2[((y_cord[j] - (y_bound_low + 1)), ((x_cord[j] - (x_bound_low + 1)) - 1))]], [o2[((y_cord[j] - (y_bound_low + 1)), (x_cord[j] - (x_bound_low + 1)))]], [o2[((y_cord[j] - (y_bound_low + 1)), ((x_cord[j] - (x_bound_low + 1)) + 1))]], [o2[(((y_cord[j] - (y_bound_low + 1)) + 1), ((x_cord[j] - (x_bound_low + 1)) - 1))]], [o2[(((y_cord[j] - (y_bound_low + 1)) + 1), (x_cord[j] - (x_bound_low + 1)))]], [o2[(((y_cord[j] - (y_bound_low + 1)) + 1), ((x_cord[j] - (x_bound_low + 1)) + 1))]]]
for u in range(0, len(TypeN_Transporter_Channel)):
    Transporter_List[u] = [item[u] for item in Special]
KbT=1
epsilon=1
negepsilion=-1
type1lows = numpy.zeros(n)#counts what particles of what types are in what area
type1highs = numpy.zeros(n)
type2lows = numpy.zeros(n)
type2highs = numpy.zeros(n)
def Transporter_Energy():
    E_component1 = 0
    E_component2 = 0
    for q in range(-1, len(Cell_Membrane) + 1):
        if (variable - ((len(TypeN_Transporter_Channel) * q) + (TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn))) in Transporter_y_cord:
            u = (variable - ((len(TypeN_Transporter_Channel) * q) + (TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn)))
            v = q + 1
            break
    if Ising_Dummy_Ends[u, v] == 1:
        if Ising_Dummy_Ends[u, v - 1] == 0:
            E_component1 = negepsilion
        if Ising_Dummy_Ends[u, v + 1] == 0:
            E_component2 = negepsilion
    elif Ising_Dummy_Ends[u, v] == 0:
        if Ising_Dummy_Ends[u, v - 1] == 1:
            E_component1 = negepsilion
        if Ising_Dummy_Ends[u, v + 1] == 1:
            E_component2 = negepsilion
    E[variable] = E_component1 + E_component2
def Particle_Energy2():
    Type1_Matrix = [[o1[(((y_cord[q] - (y_bound_low + 1) - 1)), ((x_cord[q] - (x_bound_low + 1)) - 1))]], [o1[(((y_cord[q] - (y_bound_low + 1)) - 1), (x_cord[q] - (x_bound_low + 1)))]], [o1[(((y_cord[q] - (y_bound_low + 1)) - 1), ((x_cord[q] - (x_bound_low + 1)) + 1))]], [o1[((y_cord[q] - (y_bound_low + 1)), ((x_cord[q] - (x_bound_low + 1)) - 1))]], [o1[((y_cord[q] - (y_bound_low + 1)), (x_cord[q] - (x_bound_low + 1)))]], [o1[((y_cord[q] - (y_bound_low + 1)), ((x_cord[q] - (x_bound_low + 1)) + 1))]], [o1[(((y_cord[q] - (y_bound_low + 1)) + 1), ((x_cord[q] - (x_bound_low + 1)) - 1))]], [o1[(((y_cord[q] - (y_bound_low + 1)) + 1), (x_cord[q] - (x_bound_low + 1)))]], [o1[(((y_cord[q] - (y_bound_low + 1)) + 1), ((x_cord[q] - (x_bound_low + 1)) + 1))]]]
    Type2_Matrix = [[o2[(((y_cord[q] - (y_bound_low + 1) - 1)), ((x_cord[q] - (x_bound_low + 1)) - 1))]], [o2[(((y_cord[q] - (y_bound_low + 1)) - 1), (x_cord[q] - (x_bound_low + 1)))]], [o2[(((y_cord[q] - (y_bound_low + 1)) - 1), ((x_cord[q] - (x_bound_low + 1)) + 1))]], [o2[((y_cord[q] - (y_bound_low + 1)), ((x_cord[q] - (x_bound_low + 1)) - 1))]], [o2[((y_cord[q] - (y_bound_low + 1)), (x_cord[q] - (x_bound_low + 1)))]], [o2[((y_cord[q] - (y_bound_low + 1)), ((x_cord[q] - (x_bound_low + 1)) + 1))]], [o2[(((y_cord[q] - (y_bound_low + 1)) + 1), ((x_cord[q] - (x_bound_low + 1)) - 1))]], [o2[(((y_cord[q] - (y_bound_low + 1)) + 1), (x_cord[q] - (x_bound_low + 1)))]], [o2[(((y_cord[q] - (y_bound_low + 1)) + 1), ((x_cord[q] - (x_bound_low + 1)) + 1))]]]
    if q in range(0, (TypeN_Area1Spawn + TypeN_Area2Spawn)):
        #print(j, numpy.sum(Type2j_Matrix))
        if numpy.sum(Type2_Matrix) == numpy.array([0]):
            E[q] = 0
        else:
            E[q] = negepsilion
    elif q in range((TypeN_Area1Spawn + TypeN_Area2Spawn), (TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn)):
        #print(j, numpy.sum(Type1j_Matrix))
        if numpy.sum(Type1_Matrix) == numpy.array([0]):
            E[q] = 0
        else:
            E[q] = negepsilion
def Particle_Energy():
    if x_bounds in x_cord[j]:#keeps particles from leaving the system's boundaries
        E[j] = math.inf#energy set to infinite if particle runs into x boundaries
    elif y_bounds in y_cord[j]:#this isn't the best solution, as it runs through everything a couple times, however, it does have 100% accuracy
        E[j] = math.inf#energy set to infinite if particle runs into y boundaries and membrane
    elif Cell_Membrane in y_cord[j]:#this isn't the best solution, as it runs through everything a couple times, however, it does have 100% accuracy
        if TypeS_Transporter_Channel in x_cord[j]:#sets which"end" of transporter is altered
            if j in range(0, (TypeN_Area1Spawn + TypeN_Area2Spawn)):
                E[j] = math.inf#rejects type one particles from entering the special transporters from this way
            elif mode == 0:
                if Ising_Dummy_Ends[TypeS_Transporter_Channel.index(x_cord[j]), (y_cord[j] + 1) - h] == 1:
                    E[j] = negepsilion#sets energy for particle interaction within channel
                else:
                    E[j] = 0
            elif mode == 1:
                q = j
                Particle_Energy2()
        elif TypeN_Transporter_Channel in x_cord[j]:
            if j in range((TypeN_Area1Spawn + TypeN_Area2Spawn), (TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn)):
                E[j] = math.inf#rejects type two particles from entering the special transporters from this way
            elif mode == 0:
                if Ising_Dummy_Ends[TypeN_Transporter_Channel.index(x_cord[j]), (y_cord[j] + 1) - h] == 1:
                    E[j] = negepsilion
                else:
                    E[j] = 0
            elif mode == 1:
                q = j
                Particle_Energy2()
        else:
            E[j] = math.inf
    else:
        if mode == 1:
            q = j
            Particle_Energy2()
        if mode == 0:
            E[j] = 0#default energy is 0
if mode == 1:
    for q in range(0, (TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn)):
        Particle_Energy2()
for variable in range((TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn), ((len(Cell_Membrane) * len(TypeN_Transporter_Channel)) + (TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn))):
    Transporter_Energy()
for i in range(0, n):
    #print(i)
    type1low = 0
    type1high = 0
    type2low = 0
    type2high = 0
    if mode == 0:
        j = random.randint(0, ((TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn) + (len(Cell_Membrane) * len(TypeN_Transporter_Channel)) - 1))#this picks which particle moves
    if mode == 1:
        j = random.randint(0, ((TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn) - 1))#this picks which particle moves
        q = j
        Particle_Energy2()
    E_old = E.copy() #saves old energy matrix in case the new move is rejected
    Ej_old = E[j].copy()#saves old individual energy for use in Monte Carlo rejection
    I_old = Ising_Dummy_Ends.copy()
    y_cord_old = y_cord.copy()
    x_cord_old = x_cord.copy()
    if j in range(0, (TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn)):
        P_old = Position_Matrix[j].copy() #saves old position in case the new move is rejected
        Position_Matrix[j] = P_old + random.choice(Eligible_Moves) #the new move
        Particle_Energy()
    elif j in range((TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn), (TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn) + (len(Cell_Membrane) * len(TypeN_Transporter_Channel))):
        for q in range(0, len(Cell_Membrane) + 1):
            if (j - ((len(TypeN_Transporter_Channel) * q) + (TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn))) in Transporter_y_cord:
                u = (j - ((len(TypeN_Transporter_Channel) * q) + (TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn)))
                v = q + 1
                break
        if Ising_Dummy_Ends[u, v] == 1:
            Ising_Dummy_Ends[u, v] = 0
        elif Ising_Dummy_Ends[u, v] == 0:
            Ising_Dummy_Ends[u, v] = 1
        for variable in range((j + len(TypeN_Transporter_Channel)), (j + len(TypeN_Transporter_Channel) + 1)):
            Transporter_Energy()
        for variable in range((j - len(TypeN_Transporter_Channel)), ((j - len(TypeN_Transporter_Channel)) + 1)):
            Transporter_Energy()
        for variable in range(j, (j + 1)):
            Transporter_Energy()
            Epartcount = 0
            if Ising_Dummy_Ends[u, v] == 0:
                for j in range(0, (TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn)):
                    if y_cord[j] == Cell_Membrane[q] and x_cord[j] in Transporter_List[u]:
                        Epartcount = Epartcount - negepsilion#accounts for change in particle energy within transporter when it's changing
                        copy.copy(Epartcount)
            if Ising_Dummy_Ends[u, v] == 1:
                for j in range(0, (TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn)):
                    if y_cord[j] == Cell_Membrane[q] and x_cord[j] in Transporter_List[u]:
                        Epartcount = Epartcount + negepsilion#accounts for change in particle energy within transporter when it's changing
                        copy.copy(Epartcount)
            E[j] = E[variable] + Epartcount
        for j in range(0, (TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn)):
            Particle_Energy()    
    if E[j] > Ej_old:#if the energy's lower or equal we automatically accept it
        #print(j)
        val = numpy.random.uniform(low=0, high=1, size=1)
        if val > (math.exp((Ej_old - E[j])/(KbT))):#equation will need to be changed later(rn inaccurate)
            if j in range(0, (TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn)): #resets to old state if the move is rejected
                Position_Matrix[j] = P_old
            E = E_old
            Ising_Dummy_Ends = I_old
    if j in range(0, (TypeN_Area1Spawn + TypeN_Area2Spawn)):
        o1[((y_cord[j] - (y_bound_low + 1)), (x_cord[j] - (x_bound_low + 1)))] = o1[((y_cord[j] - (y_bound_low + 1)), (x_cord[j] - (x_bound_low + 1)))] + 1
        o1[((y_cord_old[j] - (y_bound_low + 1)), (x_cord_old[j] - (x_bound_low + 1)))] = o1[((y_cord_old[j] - (y_bound_low + 1)), (x_cord_old[j] - (x_bound_low + 1)))] - 1
    if j in range((TypeN_Area1Spawn + TypeN_Area2Spawn), ((TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn))):
        o2[((y_cord[j] - (y_bound_low + 1)), (x_cord[j] - (x_bound_low + 1)))] = o2[((y_cord[j] - (y_bound_low + 1)), (x_cord[j] - (x_bound_low + 1)))] + 1
        o2[((y_cord_old[j] - (y_bound_low + 1)), (x_cord_old[j] - (x_bound_low + 1)))] = o2[((y_cord_old[j] - (y_bound_low + 1)), (x_cord_old[j] - (x_bound_low + 1)))] - 1
    if j in range((TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn), (TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn) + (len(Cell_Membrane) * len(TypeN_Transporter_Channel))):
        for variable in range(j, (j + 1)):
            Transporter_Energy()
if mode == 1:
    for q in range(0, (TypeN_Area1Spawn + TypeN_Area2Spawn + TypeS_Area1Spawn + TypeS_Area2Spawn)):
        Particle_Energy2()
