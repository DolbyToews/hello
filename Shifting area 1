import numpy
import matplotlib
import pylab
import random
import math
n=10 #number of timesteps taken
k=2 #number of "type 1" particles in area one
c=0 #number of "type 2" particles in area one
g=0 #number of "type 1" particles in area 2
f=2 #number of "type 2" particles in area 2
d=2 #number of dimensions
E = numpy.zeros(k + c + g + f)#default energy for now, may change to a equation and move placement of it
#creates a energy for each particle for each position
a=0#lower bound for overall boundaries
b=10#upper bound for overall boundaries
h=5#separates areas into area one and area two
T=1#thermal energy test value
DC1 = ([a], [b])
A = numpy.random.randint(low=a + 1, high=h - 1, size =((k + c), d))#matrix of positions of area one
A2 = numpy.random.randint(low=h + 1, high=b - 1, size =((g + f), d))#matrix of positions of area two
A5 = ((h + 1) - (a + 1)) * numpy.ones((k + c, 1))
A0 = numpy.zeros((k + c, 1))
if d == 2:
    A1 = A + numpy.concatenate((A5, A0), axis= 1)
if d == 3:
    A1 = A + numpy.concatenate((A5, A5, A0), axis= 1)
#P = numpy.concatenate((A1, A2), axis=0)#combines A1 and A2 ,as well as T1 and T2 particles,into a single matrix
#note that particles can't spawn on boundaries, but can spawn on eachother
P = numpy.concatenate((A1, A2), axis= 0)
